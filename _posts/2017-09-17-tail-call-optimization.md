---
layout: post
title: 尾调用优化
date: 2017-09-17
categories: optimize
tag: [lua, es6, tco, optimize]
---

尾调用（Tail Call）是函数式编程非常重要的概念。所谓**尾调用**，是指函数的最后一步操作是函数调用。以Lua语言为例，在这个函数定义中

```lua
function foo()
	return bar()
end
```

```foo()``` 函数的最后一步操作是返回一次```bar()```函数的调用，我们把这样的调用就称作尾调用。这里要注意以下一些情况并不属于尾调用：

```lua
-- case 1
function foo()
	local ret = bar()
	return ret
end

-- case 2
function foo()
	return bar() + 1
end

-- case 3
function foo()
	bar()
end
```
第一种情况在执行了函数调用之后，又进行了赋值操作，然后才是返回结果，这显然不是尾调用。第二种情况在执行了函数调用之后，又进行了一次加法赋值操作，因此也不属于尾调用。而第三种情况，虽然表面上看起来是最后一步做了函数调用，但实际上Lua语言在每个函数的结尾都默认执行了一次空返回的操作（如果没有返回值的话）。第三种情况相当于

```lua
function foo()
	bar()
	return nil
end
```
因此这第三种情况也不属于尾调用。使用的时候一定要注意这些情况。

当尾调用的函数是函数本身（self-called）时，我们就把这样的尾调用称作**尾递归**（Tail Recursion）。

那么，尾调用有什么意义呢？我们先来看这样的这两个函数的执行结果

```lua
function foo()
	foo()
end
```

```lua
function bar()
	return bar()
end
```
前者很快就报```stack overflow```的错误，而后者始终不会结束执行。这是什么原因呢？这里就涉及到我们本篇要讨论的主题——**尾调用优化**(**Tail Call Optimization**, **TCO**)。



我们知道，当函数内部调用函数的时候，会形成所谓的调用帧(call frame)，用于保存调用的位置以及内部声明的一些变量信息等。函数调用结束，则会回到函数调用的位置，并删除对应的调用帧。比如，函数```foo```内部调用了函数```bar```，那么```foo```所在的调用帧会形成一个```bar```的调用帧。等```bar```执行结束之后，就会返回```foo```调用```bar```的位置，并删掉```bar```的调用帧。那么如果```bar```又调用了函数```foobar```，则又会形成```foobar```的调用帧，依次类推，形成所谓**调用栈**(call stack)。对于上面的```foo```无限递归的例子，因为始终没结束帧调用，而又不断产生更多的调用帧，导致了调用栈越变越大，最终造成栈溢出。这是我们很容易理解的。

那么第二个例子中，既然```bar```函数也是进行无限递归操作，为什么不会造成栈溢出呢？我们先来看看尾调用的特殊之处。在执行尾调用的时候，由于尾调用是最后一步操作，在这一步操作之后，当前调用帧就没必要存在了（调用位置、内部变量等等都不会再用到了），因此理论上可以不保留当前调用帧，直接跳到尾调用函数的调用帧去。也就是说，对于一般的函数调用序列，在没有返回之前，我们需要保留所有的调用帧；而在尾调用中，理论上只要一调用，就把前面的调用帧删掉，只保留最后一帧即可。这样，我们的无线递归就不会因为调用栈越来越大而造成栈溢出。而这就是我们所说的尾调用优化。

前面我一直强调**理论上**，是因为尾调用优化并不是所有语言的特性。比如，Python语言就不支持尾调用优化。如下是用Python语言写的尾调用函数
```py
def foo():
    return foo();

foo();
```
不幸的是，执行这段代码会报如下错误：
```
RuntimeError: maximum recursion depth exceeded
```

而JavaScript也是在ES6的时候才引入尾调用优化的（需要开启严格模式）
```js
function foo() {
    'use strict';
    return foo();
}
```
